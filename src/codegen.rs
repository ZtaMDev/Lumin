use crate::ast::*;

/// Generate very simple JS from the component AST.
/// MVP: inject the script as-is and generate a `hydrate` function that just writes the template as text.
pub fn generate_js(component: &ComponentFile) -> String {
    let mut out: String = String::new();

    out.push_str("// Generated by luminjs MVP\n");
    out.push_str("import { signal } from './runtime.js';\n\n");

    if let Some(script) = &component.script {
        out.push_str(&script.code);
        out.push_str("\n\n");
    }

    let mut ctx = CodegenCtx::new();
    let template_html: String = component
        .template
        .iter()
        .map(|node| template_node_to_html(node, &mut ctx))
        .collect::<String>();

    out.push_str("export function renderToString() {\n");
    out.push_str("  return ");
    out.push_str(&format!("`{}`;\n", escape_backticks(&template_html)));
    out.push_str("}\n\n");

    // Map handler ids to functions in module scope
    out.push_str("const __luminHandlers = {\n");
    for (id, expr) in &ctx.handler_entries {
        // If id == expr and it's a simple identifier, use the existing
        // function from module scope. Otherwise, wrap the expression in
        // a function (for inline arrows, etc.).
        if id == expr && is_simple_identifier(expr) {
            out.push_str(&format!("  {0}: {0},\n", id));
        } else {
            out.push_str(&format!("  {}: {},\n", id, expr));
        }
    }
    out.push_str("};\n\n");

    // Map text signal names to signal functions in module scope
    out.push_str("const __luminSignals = {\n");
    for name in &ctx.text_signal_names {
        out.push_str(&format!("  {0}: {0},\n", name));
    }
    out.push_str("};\n\n");

    out.push_str("export function hydrate(root) {\n");
    out.push_str("  root.innerHTML = renderToString();\n");

    // Wire up all event handlers stored in data-lumin-on-* attributes.
    out.push_str("  const all = root.querySelectorAll('*');\n");
    out.push_str("  all.forEach((el) => {\n");
    out.push_str("    for (const attr of el.attributes) {\n");
    out.push_str("      if (!attr.name.startsWith('data-lumin-on-')) continue;\n");
    out.push_str("      const eventName = attr.name.slice('data-lumin-on-'.length);\n");
    out.push_str("      const handlerId = attr.value;\n");
    out.push_str("      const handler = __luminHandlers[handlerId];\n");
    out.push_str("      if (typeof handler === 'function') {\n");
    out.push_str("        el.addEventListener(eventName, handler);\n");
    out.push_str("      }\n");
    out.push_str("    }\n");
    out.push_str("  });\n");

    // Wire up reactive text nodes
    out.push_str("  const textTargets = root.querySelectorAll('[data-lumin-text]');\n");
    out.push_str("  textTargets.forEach((el) => {\n");
    out.push_str("    const name = el.getAttribute('data-lumin-text');\n");
    out.push_str("    const sig = __luminSignals[name];\n");
    out.push_str("    if (typeof sig === 'function') {\n");
    out.push_str("      // initial value\n");
    out.push_str("      el.textContent = String(sig());\n");
    out.push_str("      if (typeof sig._subscribe === 'function') {\n");
    out.push_str("        sig._subscribe((value) => {\n");
    out.push_str("          el.textContent = String(value);\n");
    out.push_str("        });\n");
    out.push_str("      }\n");
    out.push_str("    }\n");
    out.push_str("  });\n");

    out.push_str("}\n");

    out
}

/// Generate a component factory and register it into `__luminComponents`.
/// This output is intended to be embedded inside the bundle IIFE.
pub fn generate_component_factory_js(name: &str, component: &ComponentFile) -> String {
    let mut out = String::new();

    out.push_str(&format!("__luminComponents[\"{}\"] = (function() {{\n", name));

    // User <script> is scoped to the component
    if let Some(script) = &component.script {
        out.push_str(&script.code);
        out.push_str("\n\n");
    }

    let mut ctx = CodegenCtx::new();
    let template_html: String = component
        .template
        .iter()
        .map(|n| template_node_to_html_for_bundle(n, &mut ctx))
        .collect::<String>();

    out.push_str("function renderToString() {\n");
    out.push_str("  return `");
    out.push_str(&escape_backticks(&template_html));
    out.push_str("`;\n");
    out.push_str("}\n\n");

    out.push_str("const __luminHandlers = {\n");
    for (id, expr) in &ctx.handler_entries {
        if id == expr && is_simple_identifier(expr) {
            out.push_str(&format!("  {0}: {0},\n", id));
        } else {
            out.push_str(&format!("  {}: {},\n", id, expr));
        }
    }
    out.push_str("};\n\n");

    out.push_str("const __luminSignals = {\n");
    for n in &ctx.text_signal_names {
        out.push_str(&format!("  {0}: {0},\n", n));
    }
    out.push_str("};\n\n");

    out.push_str("function hydrate(root) {\n");
    out.push_str("  root.innerHTML = renderToString();\n");

    // Events
    out.push_str("  const all = root.querySelectorAll('*');\n");
    out.push_str("  all.forEach((el) => {\n");
    out.push_str("    for (const attr of el.attributes) {\n");
    out.push_str("      if (!attr.name.startsWith('data-lumin-on-')) continue;\n");
    out.push_str("      const eventName = attr.name.slice('data-lumin-on-'.length);\n");
    out.push_str("      const handlerId = attr.value;\n");
    out.push_str("      const handler = __luminHandlers[handlerId];\n");
    out.push_str("      if (typeof handler === 'function') {\n");
    out.push_str("        el.addEventListener(eventName, handler);\n");
    out.push_str("      }\n");
    out.push_str("    }\n");
    out.push_str("  });\n");

    // Reactive text
    out.push_str("  const textTargets = root.querySelectorAll('[data-lumin-text]');\n");
    out.push_str("  textTargets.forEach((el) => {\n");
    out.push_str("    const name = el.getAttribute('data-lumin-text');\n");
    out.push_str("    const sig = __luminSignals[name];\n");
    out.push_str("    if (typeof sig === 'function') {\n");
    out.push_str("      el.textContent = String(sig());\n");
    out.push_str("      if (typeof sig._subscribe === 'function') {\n");
    out.push_str("        sig._subscribe((value) => {\n");
    out.push_str("          el.textContent = String(value);\n");
    out.push_str("        });\n");
    out.push_str("      }\n");
    out.push_str("    }\n");
    out.push_str("  });\n");

    // Mount nested components
    out.push_str("  const mounts = root.querySelectorAll('[data-lumin-mount]');\n");
    out.push_str("  mounts.forEach((el) => {\n");
    out.push_str("    const compName = el.getAttribute('data-lumin-mount');\n");
    out.push_str("    const comp = __luminComponents[compName];\n");
    out.push_str("    if (comp && typeof comp.hydrate === 'function') {\n");
    out.push_str("      comp.hydrate(el);\n");
    out.push_str("    }\n");
    out.push_str("  });\n");

    out.push_str("}\n\n");

    out.push_str("return { renderToString, hydrate };\n");
    out.push_str("})();\n");

    out
}

fn template_node_to_html_for_bundle(node: &TemplateNode, ctx: &mut CodegenCtx) -> String {
    match node {
        TemplateNode::Element(el) => {
            // Components: any tag starting with uppercase becomes a mount point.
            if el
                .tag_name
                .chars()
                .next()
                .map(|c| c.is_ascii_uppercase())
                .unwrap_or(false)
            {
                return format!("<div data-lumin-mount=\"{}\"></div>", el.tag_name);
            }

            // Non-component element: render normally but recurse using the bundle-aware renderer
            // so nested component tags get converted too.
            let mut s = String::new();
            s.push('<');
            s.push_str(&el.tag_name);
            for attr in &el.attributes {
                s.push(' ');
                match attr {
                    AttributeNode::Static { name, value } => {
                        s.push_str(name);
                        s.push('=');
                        s.push('"');
                        s.push_str(value);
                        s.push('"');
                    }
                    AttributeNode::Dynamic { name, expr } => {
                        s.push_str(name);
                        s.push_str("=\"${");
                        s.push_str(&expr.code);
                        s.push_str("}\"");
                    }
                    AttributeNode::EventHandler { name, expr } => {
                        let event_name = event_attr_to_event_name(name);
                        let handler_id = ctx.register_handler(&expr.code);
                        s.push_str("data-lumin-on-");
                        s.push_str(&event_name);
                        s.push('=');
                        s.push('"');
                        s.push_str(&handler_id);
                        s.push('"');
                    }
                }
            }

            if el.self_closing {
                s.push_str(" />");
                return s;
            }

            s.push('>');
            for child in &el.children {
                s.push_str(&template_node_to_html_for_bundle(child, ctx));
            }
            s.push_str("</");
            s.push_str(&el.tag_name);
            s.push('>');
            s
        }
        _ => template_node_to_html(node, ctx),
    }
}

#[derive(Debug, Default)]
struct CodegenCtx {
    handler_entries: Vec<(String, String)>,
    synthetic_counter: usize,
    text_signal_names: Vec<String>,
}

impl CodegenCtx {
    fn new() -> Self {
        Self::default()
    }

    fn register_handler(&mut self, expr: &str) -> String {
        let expr = expr.trim();
        let id = if is_simple_identifier(expr) {
            expr.to_string()
        } else {
            let id = format!("h{}", self.synthetic_counter);
            self.synthetic_counter += 1;
            id
        };

        if !self
            .handler_entries
            .iter()
            .any(|(existing_id, existing_expr)| existing_id == &id && existing_expr == expr)
        {
            self.handler_entries.push((id.clone(), expr.to_string()));
        }

        id
    }

    fn register_text_signal(&mut self, name: &str) {
        if !self.text_signal_names.contains(&name.to_string()) {
            self.text_signal_names.push(name.to_string());
        }
    }
}

fn template_node_to_html(node: &TemplateNode, ctx: &mut CodegenCtx) -> String {
    match node {
        TemplateNode::Text(t) => t.to_string(),
        TemplateNode::Expr(expr) => {
            // If the expression is a simple call like `name()`, treat it
            // as a signal read and render a span we can update reactively.
            if let Some(name) = simple_call_name(&expr.code) {
                ctx.register_text_signal(&name);
                format!("<span data-lumin-text=\"{}\"></span>", name)
            } else {
                // Fallback: keep it as a template literal expression
                format!("${{{}}}", expr.code)
            }
        }
        TemplateNode::Element(el) => {
            let mut s = String::new();
            s.push('<');
            s.push_str(&el.tag_name);
            for attr in &el.attributes {
                s.push(' ');
                match attr {
                    AttributeNode::Static { name, value } => {
                        s.push_str(name);
                        s.push('=');
                        s.push('"');
                        s.push_str(value);
                        s.push('"');
                    }
                    AttributeNode::Dynamic { name, expr } => {
                        s.push_str(name);
                        s.push_str("=\"${");
                        s.push_str(&expr.code);
                        s.push_str("}\"");
                    }
                    AttributeNode::EventHandler { name, expr } => {
                        // Convert on* handlers to data attributes consumed by hydrate.
                        // Example: onClick={inc} -> data-lumin-on-click="inc"
                        //          onMouseEnter={() => ...} -> data-lumin-on-mouseenter="h0"
                        let event_name = event_attr_to_event_name(name);
                        let handler_id = ctx.register_handler(&expr.code);
                        s.push_str("data-lumin-on-");
                        s.push_str(&event_name);
                        s.push('=');
                        s.push('"');
                        s.push_str(&handler_id);
                        s.push('"');
                    }
                }
            }
            if el.self_closing {
                s.push_str(" />");
            } else {
                s.push('>');
                for child in &el.children {
                    s.push_str(&template_node_to_html(child, ctx));
                }
                s.push_str("</");
                s.push_str(&el.tag_name);
                s.push('>');
            }
            s
        }
    }
}

fn event_attr_to_event_name(attr_name: &str) -> String {
    if let Some(rest) = attr_name.strip_prefix("on") {
        rest.to_ascii_lowercase()
    } else {
        attr_name.to_ascii_lowercase()
    }
}

/// If the expression is a simple function call like `name()`, return `Some("name")`.
fn simple_call_name(expr: &str) -> Option<String> {
    let trimmed = expr.trim();
    if let Some(stripped) = trimmed.strip_suffix("()") {
        let name = stripped.trim();
        if !name.is_empty()
            && name
                .chars()
                .all(|c| c == '_' || c.is_ascii_alphanumeric())
        {
            return Some(name.to_string());
        }
    }
    None
}

fn escape_backticks(input: &str) -> String {
    input.replace('`', "\\`")
}

/// Return true if the given expression string is a simple identifier
/// like `inc` (used to distinguish named handlers from inline
/// expressions such as arrow functions).
fn is_simple_identifier(expr: &str) -> bool {
    let trimmed = expr.trim();
    if trimmed.is_empty() {
        return false;
    }
    let mut chars = trimmed.chars();
    match chars.next() {
        Some(c) if c == '_' || c.is_ascii_alphabetic() => {}
        _ => return false,
    }
    for c in chars {
        if !(c == '_' || c.is_ascii_alphanumeric()) {
            return false;
        }
    }
    true
}
