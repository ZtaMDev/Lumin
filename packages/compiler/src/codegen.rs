use crate::ast::*;

pub fn generate_js(component: &ComponentFile, component_name: &str) -> String {
    let mut out = String::new();

    out.push_str("// Generated by luminjs\n");

    let has_on_mount = component.script.as_ref().map(|s| s.code.contains("onMount")).unwrap_or(false);
    let has_on_destroy = component.script.as_ref().map(|s| s.code.contains("onDestroy")).unwrap_or(false);

    let mut runtime_imports = vec!["h", "hydrate as __hydrate", "__if", "__for"];
    if !has_on_mount { runtime_imports.push("onMount"); }
    if !has_on_destroy { runtime_imports.push("onDestroy"); }

    out.push_str(&format!("import {{ {} }} from '@luminjs/runtime';\n", runtime_imports.join(", ")));

    // Emit component imports from the --- block
    for imp in &component.imports {
        out.push_str("import ");
        let mut specifiers = Vec::new();
        for spec in &imp.specifiers {
            match spec {
                ImportSpecifier::Default(n) => specifiers.push(n.clone()),
                ImportSpecifier::Named(n) => specifiers.push(format!("{{ {} }}", n)),
                ImportSpecifier::NamedAlias { local, imported } => {
                    specifiers.push(format!("{{ {} as {} }}", imported, local))
                }
            }
        }
        out.push_str(&specifiers.join(", "));
        out.push_str(" from '");
        out.push_str(&imp.source);
        out.push_str("';\n");
    }
    out.push('\n');
    
    // Hoist imports from script block
    let (script_imports, script_body) = if let Some(script) = &component.script {
        extract_script_imports(&script.code)
    } else {
        (String::new(), String::new())
    };
    out.push_str(&script_imports);

    out.push_str(&generate_component_body(component, true, &script_body, component_name));

    out.push_str("\nexport function hydrate(root, props) {\n");
    out.push_str(&format!("  __hydrate(root, {}, props);\n", component_name));
    out.push_str("}\n");

    out
}

pub fn generate_component_factory_js(name: &str, component: &ComponentFile) -> String {
    let mut out = String::new();

    out.push_str(&format!("__luminComponents[\"{}\"] = (function() {{\n", name));
    
    // Note: For bundling, we currently don't hoist script imports automatically in the factory generator.
    // The bundler needs to handle this separately if it wants to be robust.
    // However, since generate_component_body now expects script_body, we must provide it.
    // For now, we pass the full script code if we don't assume hoisting is done by bundler globally.
    // But if we pass full code, imports will be inside function -> syntax error.
    // So we MUST extract body even here. The imports will be lost unless bundler handles them!
    // This is a known limitation for the bundler in this MVP fix. 
    // Ideally bundler should collect all imports.
    let (_, script_body) = if let Some(script) = &component.script {
        extract_script_imports(&script.code)
    } else {
        (String::new(), String::new())
    };

    // Use "Component" as internal name for factory
    let fn_name = "Component";
    out.push_str(&generate_component_body(component, false, &script_body, fn_name));
    out.push_str(&format!("\n  return {{ default: {}, hydrate: (root, props) => __hydrate(root, {}, props) }};\n", fn_name, fn_name));
    out.push_str("})();\n");

    out
}

fn generate_component_body(component: &ComponentFile, is_esm: bool, script_body: &str, fn_name: &str) -> String {
    let mut out = String::new();
    
    out.push_str(&format!("function {}(props = {{}}) {{\n", fn_name));

    if !script_body.is_empty() {
        out.push_str("  // --- User Script ---\n");
        for line in script_body.lines() {
            out.push_str("  ");
            out.push_str(line);
            out.push('\n');
        }
        out.push_str("\n");
    }

    if let Some(style) = &component.style {
        out.push_str("  // Styles\n");
        out.push_str("  if (typeof document !== 'undefined') {\n");
        out.push_str(&format!("    const styleId = 'lumin-style-{}';\n", fn_name.to_lowercase()));
        out.push_str("    if (!document.getElementById(styleId)) {\n");
        out.push_str("      const s = document.createElement('style');\n");
        out.push_str("      s.id = styleId;\n");
        out.push_str(&format!("      s.textContent = `{}`;\n", escape_backticks(&style.code)));
        out.push_str("      document.head.appendChild(s);\n");
        out.push_str("    }\n");
        out.push_str("  }\n\n");
    }

    out.push_str("  return ");
    if component.template.len() == 1 {
        out.push_str(&generate_node_h(&component.template[0], 2, !is_esm));
    } else {
        out.push_str("h('div', null, [\n");
        for (i, node) in component.template.iter().enumerate() {
            out.push_str("    ");
            out.push_str(&generate_node_h(node, 4, !is_esm));
            if i < component.template.len() - 1 {
                out.push(',');
            }
            out.push('\n');
        }
        out.push_str("  ])");
    }
    out.push_str(";\n");
    out.push_str("}\n");

    if is_esm {
        out.push_str(&format!("export default {};\n", fn_name));
        out.push_str(&format!("export {{ {} }};\n", fn_name));
    }

    out
}

fn generate_node_h(node: &TemplateNode, indent: usize, is_bundle: bool) -> String {
    let mut s = String::new();
    match node {
        TemplateNode::Text(t) => {
            s.push_str(&format!("`{}`", escape_backticks(t)));
        }
        TemplateNode::Expr(expr) => {
            s.push_str(&format!("() => ({})", expr.code));
        }
        TemplateNode::ControlFlow(cf) => {
            match cf {
                ControlFlowBlock::If {
                    condition,
                    then_branch,
                    else_ifs,
                    else_branch,
                } => {
                    s.push_str("__if(() => (");
                    s.push_str(&condition.code);
                    s.push_str("), [\n");
                    
                    // Main branch
                    s.push_str(&" ".repeat(indent + 2));
                    s.push_str("{ body: () => [\n");
                    for child in then_branch {
                        s.push_str(&" ".repeat(indent + 4));
                        s.push_str(&generate_node_h(child, indent + 4, is_bundle));
                        s.push_str(",\n");
                    }
                    s.push_str(&" ".repeat(indent + 2));
                    s.push_str("] },\n");

                    // Else-ifs
                    for (cond, branch) in else_ifs {
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("{ cond: () => (");
                        s.push_str(&cond.code);
                        s.push_str("), body: () => [\n");
                        for child in branch {
                            s.push_str(&" ".repeat(indent + 4));
                            s.push_str(&generate_node_h(child, indent + 4, is_bundle));
                            s.push_str(",\n");
                        }
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("] },\n");
                    }

                    // Else
                    if let Some(branch) = else_branch {
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("{ body: () => [\n");
                        for child in branch {
                            s.push_str(&" ".repeat(indent + 4));
                            s.push_str(&generate_node_h(child, indent + 4, is_bundle));
                            s.push_str(",\n");
                        }
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("] },\n");
                    }

                    s.push_str(&" ".repeat(indent));
                    s.push_str("])");
                }
                ControlFlowBlock::For { params, key_expr, body } => {
                    // Primitive parsing of "let item of list"
                    let parts: Vec<&str> = params.split(" of ").collect();
                    if parts.len() == 2 {
                        let item_part = parts[0].trim()
                            .replace("let ", "")
                            .replace("const ", "")
                            .replace("var ", "")
                            .trim()
                            .to_string();
                        let list_part = parts[1].trim();

                        if let Some(_key) = key_expr {
                            s.push_str(&format!("__for(() => ({}), {} => [\n", list_part, item_part));
                        } else {
                            s.push_str(&format!("__for(() => ({}), {} => [\n", list_part, item_part));
                        }
                        
                        // Wait, I should actually pass the key to __for
                        // The __for signature should be: __for(list_fn, render_fn, key_fn?)
                        
                        s = String::new(); // Clear and rebuild
                        s.push_str(&format!("__for(() => ({}), {} => [\n", list_part, item_part));
                        for child in body {
                            s.push_str(&" ".repeat(indent + 2));
                            s.push_str(&generate_node_h(child, indent + 2, is_bundle));
                            s.push_str(",\n");
                        }
                        s.push_str(&" ".repeat(indent));
                        
                        if let Some(key) = key_expr {
                            s.push_str(&format!("], {} => ({}))", item_part, key));
                        } else {
                            s.push_str("])");
                        }
                    } else {
                        s.push_str(&format!("`[Invalid For syntax: {}]`", params));
                    }
                }
            }
        }
        TemplateNode::Element(el) => {
            let is_component = el
                .tag_name
                .chars()
                .next()
                .map(|c| c.is_ascii_uppercase())
                .unwrap_or(false);

            let tag = if is_component {
                if is_bundle {
                    format!("__luminComponents['{}'].default", el.tag_name)
                } else {
                    el.tag_name.clone()
                }
            } else {
                format!("'{}'", el.tag_name)
            };

            s.push_str(&format!("h({}, ", tag));

            // Attributes
            if el.attributes.is_empty() {
                s.push_str("null");
            } else {
                s.push_str("{\n");
                for (i, attr) in el.attributes.iter().enumerate() {
                    s.push_str(&" ".repeat(indent + 2));
                    match attr {
                        AttributeNode::Static { name, value } => {
                            s.push_str(&format!("'{}': '{}'", name, escape_backticks(value)));
                        }
                        AttributeNode::Dynamic { name, expr } => {
                            s.push_str(&format!("'{}': () => ({})", name, expr.code));
                        }
                        AttributeNode::EventHandler { name, expr } => {
                            s.push_str(&format!("'{}': {}", name, expr.code.trim()));
                        }
                        AttributeNode::Bind { property, expr } => {
                            // Emit bind:property with the signal reference (not wrapped in a closure)
                            s.push_str(&format!("'bind:{}': {}", property, expr.code.trim()));
                        }
                    }
                    if i < el.attributes.len() - 1 {
                        s.push(',');
                    }
                    s.push('\n');
                }
                s.push_str(&format!("{}}}", " ".repeat(indent)));
            }

            // Children
            if !el.children.is_empty() {
                s.push_str(", [\n");
                for (i, child) in el.children.iter().enumerate() {
                    s.push_str(&" ".repeat(indent + 2));
                    s.push_str(&generate_node_h(child, indent + 2, is_bundle));
                    if i < el.children.len() - 1 {
                        s.push(',');
                    }
                    s.push('\n');
                }
                s.push_str(&format!("{}]", " ".repeat(indent)));
            }

            s.push(')');
        }
    }
    s
}

fn escape_backticks(input: &str) -> String {
    input.replace('`', "\\`").replace('$', "\\$")
}

pub fn extract_script_imports(script: &str) -> (String, String) {
    let mut imports = String::new();
    let mut body = String::new();

    for line in script.lines() {
        let trimmed = line.trim();
        if trimmed.starts_with("import ") {
            imports.push_str(line);
            imports.push('\n');
        } else {
            body.push_str(line);
            body.push('\n');
        }
    }
    (imports, body)
}
