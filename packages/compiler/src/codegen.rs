use crate::ast::*;
use std::collections::HashMap;
use crate::transpiler::transpile_ts_snippet;

// transpile_ts_to_js moved to transpiler::transpile_ts_snippet

pub fn generate_js(component: &ComponentFile, component_name: &str) -> String {
    generate_component_js_esm(component, component_name)
}

pub fn generate_component_js_esm(component: &ComponentFile, component_name: &str) -> String {
    let mut out = String::new();

    out.push_str("// Generated by LumixJS\n");
    out.push_str("import * as __LUMIX__ from 'lumix-js';\n");

    // Hoist --- imports
    for imp in &component.imports {
        out.push_str("import ");
        let specifiers: Vec<String> = imp
            .specifiers
            .iter()
            .map(|s| match s {
                ImportSpecifier::Default(n) => n.clone(),
                ImportSpecifier::Named(n) => format!("{{ {} }}", n),
                ImportSpecifier::NamedAlias { local, imported } => {
                    format!("{{ {} as {} }}", imported, local)
                }
            })
            .collect();
        out.push_str(&specifiers.join(", "));
        out.push_str(" from '");
        out.push_str(&imp.source);
        out.push_str("';\n");
    }
    
    // Hoist <script> imports
    if let Some(script) = &component.script {
        for imp in &script.imports {
            // Already transpiled in parser
            out.push_str(&imp.code);
            out.push('\n');
        }
    }
    out.push('\n');
    
    let script_body_raw = component.script.as_ref().map(|s| s.code.as_str()).unwrap_or("");
    // Already transpiled in parser
    let script_body = script_body_raw.to_string();
    
    out.push_str(&generate_component_body(component, true, &script_body, component_name));

    out.push_str("\nexport function hydrate(root, props) {\n");
    out.push_str(&format!("  __LUMIX__.hydrate(root, {}, props);\n", component_name));
    out.push_str("}\n");

    out
}

pub fn generate_component_factory_js(name: &str, component: &ComponentFile) -> String {
    let mut out = String::new();

    out.push_str(&format!("__lumixComponents[\"{}\"] = (function() {{\n", name));
    
    let script_body_raw = component.script.as_ref().map(|s| s.code.as_str()).unwrap_or("");
    // Already transpiled in parser
    let script_body = script_body_raw.to_string();

    // Use "Component" as internal name for factory
    let fn_name = "Component";
    out.push_str(&generate_component_body(component, false, &script_body, fn_name));
    out.push_str(&format!("\n  return {{ default: {}, hydrate: (root, props) => __LUMIX__.hydrate(root, {}, props) }};\n", fn_name, fn_name));
    out.push_str("})();\n");

    out
}

fn generate_component_body(component: &ComponentFile, is_esm: bool, script_body: &str, fn_name: &str) -> String {
    let mut out = String::new();
    
    out.push_str(&format!("function {}(props = {{}}) {{\n", fn_name));

    // Emit prop destructuring and validation
    if let Some(script) = &component.script {
        if !script.props.is_empty() {
            let mut destructuring = Vec::new();
            let mut required_props = Vec::new();
            for prop in &script.props {
                if let Some(default) = &prop.default_value {
                    destructuring.push(format!("{} = {}", prop.name, transpile_ts_snippet(default).trim()));
                } else {
                    destructuring.push(prop.name.clone());
                    required_props.push(prop.name.clone());
                }
            }
            out.push_str(&format!("  let {{ {} }} = props;\n", destructuring.join(", ")));
            
            for prop_name in required_props {
                out.push_str(&format!("  if ({} === undefined) throw new Error(\"LumixJS: Component '{}' missing required prop '{}'\");\n", prop_name, fn_name, prop_name));
            }
            out.push('\n');
        }
    }

    if !script_body.is_empty() {
        for line in script_body.lines() {
            let trimmed = line.trim();
            if !trimmed.is_empty() {
                out.push_str("  ");
                out.push_str(line);
                out.push('\n');
            }
        }
        out.push('\n');
    }

    if let Some(style) = &component.style {
        out.push_str("  // Styles\n");
        out.push_str("  if (typeof document !== 'undefined') {\n");
        out.push_str(&format!("    const styleId = 'lumix-style-{}';\n", fn_name.to_lowercase()));
        out.push_str("    if (!document.getElementById(styleId)) {\n");
        out.push_str("      const s = document.createElement('style');\n");
        out.push_str("      s.id = styleId;\n");
        out.push_str(&format!("      s.textContent = `{}`;\n", escape_backticks(&style.code)));
        out.push_str("      document.head.appendChild(s);\n");
        out.push_str("    }\n");
        out.push_str("  }\n\n");
    }

    out.push_str("  return ");
    if component.template.len() == 1 {
        // Single root: return that node directly.
        out.push_str(&generate_node_h(&component.template[0], 2, !is_esm, false));
    } else {
        // Multiple roots: use Fragment so we don't introduce an extra wrapper div.
        out.push_str("__LUMIX__.h(__LUMIX__.Fragment, null, ");
        for (i, node) in component.template.iter().enumerate() {
            if i > 0 {
                out.push_str(", ");
            }
            out.push_str(&generate_node_h(node, 2, !is_esm, false));
        }
        out.push_str(")");
    }
    out.push_str(";\n");
    out.push_str("}\n");

    if is_esm {
        out.push_str(&format!("export default {};\n", fn_name));
        out.push_str(&format!("export {{ {} }};\n", fn_name));
    }

    // HMR helper: expose the component factory as a stable binding.
    // The Vite plugin uses this to capture the root component at runtime.
    out.push_str(&format!("const __LUMIX_ROOT__ = {};\n", fn_name));

    out
}

fn generate_node_h(node: &TemplateNode, indent: usize, is_bundle: bool, strip_slot_attr: bool) -> String {
    let mut s = String::new();
    match node {
        TemplateNode::Text(t) => {
            s.push_str(&format!("`{}`", escape_backticks(t)));
        }
        TemplateNode::Expr(expr) => {
            s.push_str(&format!("() => ({})", transpile_ts_snippet(&expr.code).trim()));
        }
        TemplateNode::Slot(slot) => {
            let is_default = slot.name.is_none();
            let mut fallback_js = String::from("[]");
            if !slot.fallback.is_empty() {
                let mut fallback_s = String::from("[\n");
                for (i, node) in slot.fallback.iter().enumerate() {
                    fallback_s.push_str(&" ".repeat(indent + 2));
                    fallback_s.push_str(&generate_node_h(node, indent + 2, is_bundle, false));
                    if i < slot.fallback.len() - 1 {
                        fallback_s.push(',');
                    }
                    fallback_s.push('\n');
                }
                fallback_s.push_str(&format!("{}]", " ".repeat(indent)));
                fallback_js = fallback_s;
            }
            
            if is_default {
                s.push_str(&format!("(props.children ? props.children() : {})", fallback_js));
            } else {
                let name = slot.name.as_ref().unwrap();
                s.push_str(&format!("(props.slots?.{} ? props.slots.{}() : {})", name, name, fallback_js));
            }
        }
        TemplateNode::ControlFlow(cf) => {
            match cf {
                ControlFlowBlock::If {
                    condition,
                    then_branch,
                    else_ifs,
                    else_branch,
                } => {
                    s.push_str("__LUMIX__.__if(() => (");
                    s.push_str(transpile_ts_snippet(&condition.code).trim());
                    s.push_str("), [\n");
                    
                    // Main branch
                    s.push_str(&" ".repeat(indent + 2));
                    s.push_str("{ body: () => [\n");
                    for child in then_branch {
                        s.push_str(&" ".repeat(indent + 4));
                        s.push_str(&generate_node_h(child, indent + 4, is_bundle, false));
                        s.push_str(",\n");
                    }
                    s.push_str(&" ".repeat(indent + 2));
                    s.push_str("] },\n");
                    // Else-ifs
                    for (cond, branch) in else_ifs {
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("{ cond: () => (");
                        s.push_str(transpile_ts_snippet(&cond.code).trim());
                        s.push_str("), body: () => [\n");
                        for child in branch {
                            s.push_str(&" ".repeat(indent + 4));
                            s.push_str(&generate_node_h(child, indent + 4, is_bundle, false));
                            s.push_str(",\n");
                        }
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("] },\n");
                    }

                    // Else
                    if let Some(branch) = else_branch {
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("{ body: () => [\n");
                        for child in branch {
                            s.push_str(&" ".repeat(indent + 4));
                            s.push_str(&generate_node_h(child, indent + 4, is_bundle, false));
                            s.push_str(",\n");
                        }
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("] },\n");
                    }

                    s.push_str(&" ".repeat(indent));
                    s.push_str("])");
                }
                ControlFlowBlock::For { params, key_expr, body } => {
                    // Primitive parsing of "let item of list"
                    let parts: Vec<&str> = params.split(" of ").collect();
                    if parts.len() == 2 {
                        let item_part = parts[0].trim()
                            .replace("let ", "")
                            .replace("const ", "")
                            .replace("var ", "")
                                .trim()
                            .to_string();
                        let list_part = transpile_ts_snippet(parts[1].trim());

                        s.push_str(&format!("__LUMIX__.__for(() => ({}), {} => [\n", list_part.trim(), item_part));
                        for child in body {
                            s.push_str(&" ".repeat(indent + 2));
                            s.push_str(&generate_node_h(child, indent + 2, is_bundle, false));
                            s.push_str(",\n");
                        }
                        s.push_str(&" ".repeat(indent));
                        
                        if let Some(key) = key_expr {
                            s.push_str(&format!("], {} => ({}))", item_part, transpile_ts_snippet(key).trim()));
                        } else {
                            s.push_str("])");
                        }
                    } else {
                        s.push_str(&format!("`[Invalid For syntax: {}]`", params));
                    }
                }
            }
        }
        TemplateNode::Element(el) => {
            let is_component = el
                .tag_name
                .chars()
                .next()
                .map(|c| c.is_ascii_uppercase())
                .unwrap_or(false);

            let tag = if is_component {
                if is_bundle {
                    format!("__luminComponents['{}'].default", el.tag_name)
                } else {
                    el.tag_name.clone()
                }
            } else {
                format!("'{}'", el.tag_name)
            };

            s.push_str(&format!("__LUMIX__.h({}, ", tag));

            let mut slots: HashMap<String, Vec<&TemplateNode>> = HashMap::new();
            let mut default_children: Vec<&TemplateNode> = Vec::new();

            if is_component {
                for child in &el.children {
                    let mut assigned_slot = None;
                    if let TemplateNode::Element(child_el) = child {
                        for attr in &child_el.attributes {
                            if let AttributeNode::Static { name, value } = attr {
                                if name == "slot" {
                                    assigned_slot = Some(value.clone());
                                    break;
                                }
                            }
                        }
                    }
                    
                    if let Some(name) = assigned_slot {
                        slots.entry(name).or_default().push(child);
                    } else {
                        default_children.push(child);
                    }
                }
            }

            // Attributes and Slots
            if el.attributes.is_empty() && slots.is_empty() && default_children.is_empty() {
                s.push_str("null");
            } else {
                s.push_str("{\n");
                for (i, attr) in el.attributes.iter().enumerate() {
                    s.push_str(&" ".repeat(indent + 2));
                    match attr {
                        AttributeNode::Static { name, value } => {
                            if strip_slot_attr && name == "slot" {
                                continue;
                            }
                            s.push_str(&format!("'{}': '{}'", name, escape_backticks(value)));
                        }
                        AttributeNode::Dynamic { name, expr } => {
                            // Wrap to auto-unwrap signals/functions for common reactive values.
                            // This makes `value={name}` behave like `value={name()}` when `name` is a Signal.
                            let t = transpile_ts_snippet(&expr.code);
                            let e = t.trim();
                            s.push_str(&format!(
                                "'{}': () => {{ const __v = ({}); return (typeof __v === 'function') ? __v() : __v; }}",
                                name, e
                            ));
                        }
                        AttributeNode::EventHandler { name, expr } => {
                            s.push_str(&format!("'{}': {}", name, transpile_ts_snippet(&expr.code).trim()));
                        }
                        AttributeNode::Bind { property, expr } => {
                            s.push_str(&format!("'bind:{}': {}", property, transpile_ts_snippet(&expr.code).trim()));
                        }
                    }
                    if i < el.attributes.len() - 1 || !slots.is_empty() || !default_children.is_empty() {
                        s.push(',');
                    }
                    s.push('\n');
                }

                if is_component {
                    // Default slot (children)
                    if !default_children.is_empty() {
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("'children': () => [\n");
                        for (i, child) in default_children.iter().enumerate() {
                            s.push_str(&" ".repeat(indent + 4));
                            s.push_str(&generate_node_h(child, indent + 4, is_bundle, true));
                            if i < default_children.len() - 1 {
                                s.push(',');
                            }
                            s.push('\n');
                        }
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("]");
                        if !slots.is_empty() {
                            s.push(',');
                        }
                        s.push('\n');
                    }

                    // Named slots
                    if !slots.is_empty() {
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("'slots': {\n");
                        let mut slot_keys: Vec<_> = slots.keys().collect();
                        slot_keys.sort();
                        for (sk_idx, name) in slot_keys.iter().enumerate() {
                            let children = &slots[*name];
                            s.push_str(&" ".repeat(indent + 4));
                            s.push_str(&format!("'{}': () => [\n", name));
                            for (i, child) in children.iter().enumerate() {
                                s.push_str(&" ".repeat(indent + 6));
                                s.push_str(&generate_node_h(child, indent + 6, is_bundle, true));
                                if i < children.len() - 1 {
                                    s.push(',');
                                }
                                s.push('\n');
                            }
                            s.push_str(&" ".repeat(indent + 4));
                            s.push_str("]");
                            if sk_idx < slot_keys.len() - 1 {
                                s.push(',');
                            }
                            s.push('\n');
                        }
                        s.push_str(&" ".repeat(indent + 2));
                        s.push_str("}\n");
                    }
                }

                s.push_str(&format!("{}}}", " ".repeat(indent)));
            }

            // For non-components, children still go as the third argument
            if !is_component && !el.children.is_empty() {
                s.push_str(", [\n");
                for (i, child) in el.children.iter().enumerate() {
                    s.push_str(&" ".repeat(indent + 2));
                    s.push_str(&generate_node_h(child, indent + 2, is_bundle, false));
                    if i < el.children.len() - 1 {
                        s.push(',');
                    }
                    s.push('\n');
                }
                s.push_str(&format!("{}]", " ".repeat(indent)));
            }

            s.push(')');
        }
    }
    s
}

fn escape_backticks(input: &str) -> String {
    input.replace('`', "\\`").replace('$', "\\$")
}
