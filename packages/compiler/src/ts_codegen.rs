use crate::ast::*;

pub fn generate_ts(component: &ComponentFile, _component_name: &str) -> String {
    let mut out = String::new();

    out.push_str("// Generated by luminjs for type checking\n");
    out.push_str("import * as __LUMIN__ from 'luminjs';\n");

    // Hoist --- imports
    for imp in &component.imports {
        out.push_str("import ");
        let specifiers: Vec<String> = imp
            .specifiers
            .iter()
            .map(|s| match s {
                ImportSpecifier::Default(n) => n.clone(),
                ImportSpecifier::Named(n) => format!("{{ {} }}", n),
                ImportSpecifier::NamedAlias { local, imported } => {
                    format!("{{ {} as {} }}", imported, local)
                }
            })
            .collect();
        out.push_str(&specifiers.join(", "));
        out.push_str(" from '");
        out.push_str(&imp.source);
        out.push_str("';\n");
    }

    if let Some(script) = &component.script {
        // Original script block (with types)
        out.push_str("\n// --- Script Start ---\n");
        if let Some(span) = script.span {
            out.push_str(&format!("/* @L:{} */", span.start));
        }
        out.push_str(&script.original_code);
        out.push_str("\n// --- Script End ---\n\n");

        // Dummy function to check template expressions
        out.push_str("function __lumin_template_check() {\n");
        collect_template_expressions(&component.template, &mut out);
        out.push_str("}\n");
    }

    out
}

fn collect_template_expressions(nodes: &[TemplateNode], out: &mut String) {
    for node in nodes {
        match node {
            TemplateNode::Expr(expr) => {
                if let Some(span) = expr.span {
                    out.push_str(&format!("  ((/* @L:{} */{}));\n", span.start, expr.code));
                } else {
                    out.push_str(&format!("  (({}));\n", expr.code));
                }
            }
            TemplateNode::Element(el) => {
                for attr in &el.attributes {
                    match attr {
                        AttributeNode::Dynamic { expr, .. } => {
                            if let Some(span) = expr.span {
                                out.push_str(&format!("  ((/* @L:{} */{}));\n", span.start, expr.code));
                            } else {
                                out.push_str(&format!("  (({}));\n", expr.code));
                            }
                        }
                        AttributeNode::EventHandler { expr, .. } => {
                            if let Some(span) = expr.span {
                                out.push_str(&format!("  ((/* @L:{} */{}));\n", span.start, expr.code));
                            } else {
                                out.push_str(&format!("  (({}));\n", expr.code));
                            }
                        }
                        AttributeNode::Bind { expr, .. } => {
                            if let Some(span) = expr.span {
                                out.push_str(&format!("  ((/* @L:{} */{}));\n", span.start, expr.code));
                            } else {
                                out.push_str(&format!("  (({}));\n", expr.code));
                            }
                        }
                        _ => {}
                    }
                }
                collect_template_expressions(&el.children, out);
            }
            TemplateNode::ControlFlow(cf) => match cf {
                ControlFlowBlock::If { condition, then_branch, else_ifs, else_branch } => {
                    if let Some(span) = condition.span {
                        out.push_str(&format!("  ((/* @L:{} */{}));\n", span.start, condition.code));
                    } else {
                        out.push_str(&format!("  (({}));\n", condition.code));
                    }
                    collect_template_expressions(then_branch, out);
                    for (cond, branch) in else_ifs {
                        if let Some(span) = cond.span {
                            out.push_str(&format!("  ((/* @L:{} */{}));\n", span.start, cond.code));
                        } else {
                            out.push_str(&format!("  (({}));\n", cond.code));
                        }
                        collect_template_expressions(branch, out);
                    }
                    if let Some(branch) = else_branch {
                        collect_template_expressions(branch, out);
                    }
                }
                ControlFlowBlock::For { params, body, .. } => {
                    // Try to extract variable from "item of items"
                    if let Some((item, list)) = params.split_once(" of ") {
                        out.push_str(&format!("  for (const {} of {}) {{\n", item.trim(), list.trim()));
                        collect_template_expressions(body, out);
                        out.push_str("  }\n");
                    } else {
                        collect_template_expressions(body, out);
                    }
                }
            },
            TemplateNode::Slot(slot) => {
                collect_template_expressions(&slot.fallback, out);
            }
            TemplateNode::Text(_) => {}
        }
    }
}
